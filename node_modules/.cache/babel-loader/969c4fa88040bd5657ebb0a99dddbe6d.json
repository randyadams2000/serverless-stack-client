{"ast":null,"code":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});/// <reference types=\"node\"/>\nvar int64_buffer_1=require(\"int64-buffer\");var EBMLEncoder_1=require(\"./EBMLEncoder\");var _Buffer=require(\"buffer/\");var _tools=require(\"ebml/lib/ebml/tools\");var _block=require(\"ebml-block\");exports.Buffer=_Buffer.Buffer;exports.readVint=_tools.readVint;exports.writeVint=_tools.writeVint;exports.ebmlBlock=_block;function readBlock(buf){return exports.ebmlBlock(new exports.Buffer(buf));}exports.readBlock=readBlock;/**\n  * @param end - if end === false then length is unknown\n  */function encodeTag(tagId,tagData,unknownSize){if(unknownSize===void 0){unknownSize=false;}return concat([tagId,unknownSize?new exports.Buffer('01ffffffffffffff','hex'):exports.writeVint(tagData.length),tagData]);}exports.encodeTag=encodeTag;/**\n * @return - SimpleBlock to WebP Filter\n */function WebPFrameFilter(elms){return WebPBlockFilter(elms).reduce(function(lst,elm){var o=exports.ebmlBlock(elm.data);return o.frames.reduce(function(lst,frame){// https://developers.Blob.com/speed/webp/docs/riff_container\nvar webpBuf=VP8BitStreamToRiffWebPBuffer(frame);var webp=new Blob([webpBuf],{type:\"image/webp\"});return lst.concat(webp);},lst);},[]);}exports.WebPFrameFilter=WebPFrameFilter;/**\n * WebP ファイルにできる SimpleBlock の パスフィルタ\n */function WebPBlockFilter(elms){return elms.reduce(function(lst,elm){if(elm.type!==\"b\"){return lst;}if(elm.name!==\"SimpleBlock\"){return lst;}var o=exports.ebmlBlock(elm.data);var hasWebP=o.frames.some(function(frame){// https://tools.ietf.org/html/rfc6386#section-19.1\nvar startcode=frame.slice(3,6).toString(\"hex\");return startcode===\"9d012a\";});if(!hasWebP){return lst;}return lst.concat(elm);},[]);}exports.WebPBlockFilter=WebPBlockFilter;/**\n * @param frame - VP8 BitStream のうち startcode をもつ frame\n * @return - WebP ファイルの ArrayBuffer\n */function VP8BitStreamToRiffWebPBuffer(frame){var VP8Chunk=createRIFFChunk(\"VP8 \",frame);var WebPChunk=concat([new exports.Buffer(\"WEBP\",\"ascii\"),VP8Chunk]);return createRIFFChunk(\"RIFF\",WebPChunk);}exports.VP8BitStreamToRiffWebPBuffer=VP8BitStreamToRiffWebPBuffer;/**\n * RIFF データチャンクを作る\n */function createRIFFChunk(FourCC,chunk){var chunkSize=new exports.Buffer(4);chunkSize.writeUInt32LE(chunk.byteLength,0);return concat([new exports.Buffer(FourCC.substr(0,4),\"ascii\"),chunkSize,chunk,new exports.Buffer(chunk.byteLength%2===0?0:1)// padding\n]);}exports.createRIFFChunk=createRIFFChunk;/* Original Metadata\n\n m  0\tEBML\n u  1\t  EBMLVersion 1\n u  1\t  EBMLReadVersion 1\n u  1\t  EBMLMaxIDLength 4\n u  1\t  EBMLMaxSizeLength 8\n s  1\t  DocType webm\n u  1\t  DocTypeVersion 4\n u  1\t  DocTypeReadVersion 2\n m  0\tSegment\n m  1\t  Info                                segmentContentStartPos, all CueClusterPositions provided in info.cues will be relative to here and will need adjusted\n u  2\t    TimecodeScale 1000000\n 8  2\t    MuxingApp Chrome\n 8  2\t    WritingApp Chrome\n m  1\t  Tracks                              tracksStartPos\n m  2\t    TrackEntry\n u  3\t      TrackNumber 1\n u  3\t      TrackUID 31790271978391090\n u  3\t      TrackType 2\n s  3\t      CodecID A_OPUS\n b  3\t      CodecPrivate <Buffer 19>\n m  3\t      Audio\n f  4\t        SamplingFrequency 48000\n u  4\t        Channels 1\n m  2\t    TrackEntry\n u  3\t      TrackNumber 2\n u  3\t      TrackUID 24051277436254136\n u  3\t      TrackType 1\n s  3\t      CodecID V_VP8\n m  3\t      Video\n u  4\t        PixelWidth 1024\n u  4\t        PixelHeight 576\n m  1\t  Cluster                             clusterStartPos\n u  2\t    Timecode 0\n b  2\t    SimpleBlock track:2 timecode:0\tkeyframe:true\tinvisible:false\tdiscardable:false\tlacing:1\n*/ /* Desired Metadata\n\n m\t0 EBML\n u\t1   EBMLVersion 1\n u\t1   EBMLReadVersion 1\n u\t1   EBMLMaxIDLength 4\n u\t1   EBMLMaxSizeLength 8\n s\t1   DocType webm\n u\t1   DocTypeVersion 4\n u\t1   DocTypeReadVersion 2\n m\t0 Segment\n m\t1   SeekHead                            -> This is SeekPosition 0, so all SeekPositions can be calculated as (bytePos - segmentContentStartPos), which is 44 in this case\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x15, 0x49, 0xA9, 0x66])  Info\n u\t3       SeekPosition                    -> infoStartPos =\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x16, 0x54, 0xAE, 0x6B])  Tracks\n u\t3       SeekPosition { tracksStartPos }\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x1C, 0x53, 0xBB, 0x6B])  Cues\n u\t3       SeekPosition { cuesStartPos }\n m\t1   Info\n f\t2     Duration 32480                    -> overwrite, or insert if it doesn't exist\n u\t2     TimecodeScale 1000000\n 8\t2     MuxingApp Chrome\n 8\t2     WritingApp Chrome\n m\t1   Tracks\n m\t2     TrackEntry\n u\t3       TrackNumber 1\n u\t3       TrackUID 31790271978391090\n u\t3       TrackType 2\n s\t3       CodecID A_OPUS\n b\t3       CodecPrivate <Buffer 19>\n m\t3       Audio\n f\t4         SamplingFrequency 48000\n u\t4         Channels 1\n m\t2     TrackEntry\n u\t3       TrackNumber 2\n u\t3       TrackUID 24051277436254136\n u\t3       TrackType 1\n s\t3       CodecID V_VP8\n m\t3       Video\n u\t4         PixelWidth 1024\n u\t4         PixelHeight 576\n m  1   Cues                                -> cuesStartPos\n m  2     CuePoint\n u  3       CueTime 0\n m  3       CueTrackPositions\n u  4         CueTrack 1\n u  4         CueClusterPosition 3911\n m  2     CuePoint\n u  3       CueTime 600\n m  3       CueTrackPositions\n u  4         CueTrack 1\n u  4         CueClusterPosition 3911\n m  1   Cluster\n u  2     Timecode 0\n b  2     SimpleBlock track:2 timecode:0\tkeyframe:true\tinvisible:false\tdiscardable:false\tlacing:1\n*/ /**\n * convert the metadata from a streaming webm bytestream to a seekable file by inserting Duration, Seekhead and Cues\n * @param originalMetadata - orginal metadata (everything before the clusters start) from media recorder\n * @param duration - Duration (TimecodeScale)\n * @param cues - cue points for clusters\n */function makeMetadataSeekable(originalMetadata,duration,cuesInfo){// extract the header, we can reuse this as-is\nvar header=extractElement(\"EBML\",originalMetadata);var headerSize=encodedSizeOfEbml(header);//console.error(\"Header size: \" + headerSize);\n//printElementIds(header);\n// After the header comes the Segment open tag, which in this implementation is always 12 bytes (4 byte id, 8 byte 'unknown length')\n// After that the segment content starts. All SeekPositions and CueClusterPosition must be relative to segmentContentStartPos\nvar segmentContentStartPos=headerSize+12;//console.error(\"segmentContentStartPos: \" + segmentContentStartPos);    \n// find the original metadata size, and adjust it for header size and Segment start element so we can keep all positions relative to segmentContentStartPos\nvar originalMetadataSize=originalMetadata[originalMetadata.length-1].dataEnd-segmentContentStartPos;//console.error(\"Original Metadata size: \" + originalMetadataSize);\n//printElementIds(originalMetadata);\n// extract the segment info, remove the potentially existing Duration element, and add our own one.\nvar info=extractElement(\"Info\",originalMetadata);removeElement(\"Duration\",info);info.splice(1,0,{name:\"Duration\",type:\"f\",data:createFloatBuffer(duration,8)});var infoSize=encodedSizeOfEbml(info);//console.error(\"Info size: \" + infoSize);\n//printElementIds(info);  \n// extract the track info, we can re-use this as is\nvar tracks=extractElement(\"Tracks\",originalMetadata);var tracksSize=encodedSizeOfEbml(tracks);//console.error(\"Tracks size: \" + tracksSize);\n//printElementIds(tracks);  \nvar seekHeadSize=47;// Initial best guess, but could be slightly larger if the Cues element is huge.\nvar seekHead=[];var cuesSize=5+cuesInfo.length*15;// very rough initial approximation, depends a lot on file size and number of CuePoints                   \nvar cues=[];var lastSizeDifference=-1;// \n// The size of SeekHead and Cues elements depends on how many bytes the offsets values can be encoded in.\n// The actual offsets in CueClusterPosition depend on the final size of the SeekHead and Cues elements\n// We need to iteratively converge to a stable solution.\nvar maxIterations=10;var _loop_1=function _loop_1(i){// SeekHead starts at 0\nvar infoStart=seekHeadSize;// Info comes directly after SeekHead\nvar tracksStart=infoStart+infoSize;// Tracks comes directly after Info\nvar cuesStart=tracksStart+tracksSize;// Cues starts directly after \nvar newMetadataSize=cuesStart+cuesSize;// total size of metadata  \n// This is the offset all CueClusterPositions should be adjusted by due to the metadata size changing.\nvar sizeDifference=newMetadataSize-originalMetadataSize;// console.error(`infoStart: ${infoStart}, infoSize: ${infoSize}`);\n// console.error(`tracksStart: ${tracksStart}, tracksSize: ${tracksSize}`);\n// console.error(`cuesStart: ${cuesStart}, cuesSize: ${cuesSize}`);\n// console.error(`originalMetadataSize: ${originalMetadataSize}, newMetadataSize: ${newMetadataSize}, sizeDifference: ${sizeDifference}`); \n// create the SeekHead element\nseekHead=[];seekHead.push({name:\"SeekHead\",type:\"m\",isEnd:false});seekHead.push({name:\"Seek\",type:\"m\",isEnd:false});seekHead.push({name:\"SeekID\",type:\"b\",data:new exports.Buffer([0x15,0x49,0xA9,0x66])});// Info\nseekHead.push({name:\"SeekPosition\",type:\"u\",data:createUIntBuffer(infoStart)});seekHead.push({name:\"Seek\",type:\"m\",isEnd:true});seekHead.push({name:\"Seek\",type:\"m\",isEnd:false});seekHead.push({name:\"SeekID\",type:\"b\",data:new exports.Buffer([0x16,0x54,0xAE,0x6B])});// Tracks\nseekHead.push({name:\"SeekPosition\",type:\"u\",data:createUIntBuffer(tracksStart)});seekHead.push({name:\"Seek\",type:\"m\",isEnd:true});seekHead.push({name:\"Seek\",type:\"m\",isEnd:false});seekHead.push({name:\"SeekID\",type:\"b\",data:new exports.Buffer([0x1C,0x53,0xBB,0x6B])});// Cues\nseekHead.push({name:\"SeekPosition\",type:\"u\",data:createUIntBuffer(cuesStart)});seekHead.push({name:\"Seek\",type:\"m\",isEnd:true});seekHead.push({name:\"SeekHead\",type:\"m\",isEnd:true});seekHeadSize=encodedSizeOfEbml(seekHead);//console.error(\"SeekHead size: \" + seekHeadSize);\n//printElementIds(seekHead);  \n// create the Cues element\ncues=[];cues.push({name:\"Cues\",type:\"m\",isEnd:false});cuesInfo.forEach(function(_a){var CueTrack=_a.CueTrack,CueClusterPosition=_a.CueClusterPosition,CueTime=_a.CueTime;cues.push({name:\"CuePoint\",type:\"m\",isEnd:false});cues.push({name:\"CueTime\",type:\"u\",data:createUIntBuffer(CueTime)});cues.push({name:\"CueTrackPositions\",type:\"m\",isEnd:false});cues.push({name:\"CueTrack\",type:\"u\",data:createUIntBuffer(CueTrack)});//console.error(`CueClusterPosition: ${CueClusterPosition}, Corrected to: ${CueClusterPosition - segmentContentStartPos}  , offset by ${sizeDifference} to become ${(CueClusterPosition - segmentContentStartPos) + sizeDifference - segmentContentStartPos}`);\n// EBMLReader returns CueClusterPosition with absolute byte offsets. The Cues section expects them as offsets from the first level 1 element of the Segment, so we need to adjust it.\nCueClusterPosition-=segmentContentStartPos;// We also need to adjust to take into account the change in metadata size from when EBMLReader read the original metadata.\nCueClusterPosition+=sizeDifference;cues.push({name:\"CueClusterPosition\",type:\"u\",data:createUIntBuffer(CueClusterPosition)});cues.push({name:\"CueTrackPositions\",type:\"m\",isEnd:true});cues.push({name:\"CuePoint\",type:\"m\",isEnd:true});});cues.push({name:\"Cues\",type:\"m\",isEnd:true});cuesSize=encodedSizeOfEbml(cues);//console.error(\"Cues size: \" + cuesSize);   \n//console.error(\"Cue count: \" + cuesInfo.length);\n//printElementIds(cues);      \n// If the new MetadataSize is not the same as the previous iteration, we need to run once more.\nif(lastSizeDifference!==sizeDifference){lastSizeDifference=sizeDifference;if(i===maxIterations-1){throw new Error(\"Failed to converge to a stable metadata size\");}}else{return\"break\";}};for(var i=0;i<maxIterations;i++){var state_1=_loop_1(i);if(state_1===\"break\")break;}var finalMetadata=[].concat.apply([],[header,{name:\"Segment\",type:\"m\",isEnd:false,unknownSize:true},seekHead,info,tracks,cues]);var result=new EBMLEncoder_1.default().encode(finalMetadata);//printElementIds(finalMetadata);\n//console.error(`Final metadata buffer size: ${result.byteLength}`);\n//console.error(`Final metadata buffer size without header and segment: ${result.byteLength-segmentContentStartPos}`);\nreturn result;}exports.makeMetadataSeekable=makeMetadataSeekable;/**\n * print all element id names in a list\n\n * @param metadata - array of EBML elements to print\n *\nexport function printElementIds(metadata: EBML.EBMLElementBuffer[]) {\n\n  let result: EBML.EBMLElementBuffer[] = [];\n  let start: number = -1;\n\n  for (let i = 0; i < metadata.length; i++) {\n    console.error(\"\\t id: \" + metadata[i].name);\n  }\n}\n*/ /**\n * remove all occurances of an EBML element from an array of elements\n * If it's a MasterElement you will also remove the content. (everything between start and end)\n * @param idName - name of the EBML Element to remove.\n * @param metadata - array of EBML elements to search\n */function removeElement(idName,metadata){var result=[];var start=-1;for(var i=0;i<metadata.length;i++){var element=metadata[i];if(element.name===idName){// if it's a Master element, extract the start and end element, and everything in between\nif(element.type===\"m\"){if(!element.isEnd){start=i;}else{// we've reached the end, extract the whole thing\nif(start==-1)throw new Error(\"Detected \"+idName+\" closing element before finding the start\");metadata.splice(start,i-start+1);return;}}else{// not a Master element, so we've found what we're looking for.\nmetadata.splice(i,1);return;}}}}exports.removeElement=removeElement;/**\n * extract the first occurance of an EBML tag from a flattened array of EBML data.\n * If it's a MasterElement you will also get the content. (everything between start and end)\n * @param idName - name of the EBML Element to extract.\n * @param metadata - array of EBML elements to search\n */function extractElement(idName,metadata){var result=[];var start=-1;for(var i=0;i<metadata.length;i++){var element=metadata[i];if(element.name===idName){// if it's a Master element, extract the start and end element, and everything in between\nif(element.type===\"m\"){if(!element.isEnd){start=i;}else{// we've reached the end, extract the whole thing\nif(start==-1)throw new Error(\"Detected \"+idName+\" closing element before finding the start\");result=metadata.slice(start,i+1);break;}}else{// not a Master element, so we've found what we're looking for.\nresult.push(metadata[i]);break;}}}return result;}exports.extractElement=extractElement;/**\n * @deprecated\n * metadata に対して duration と seekhead を追加した metadata を返す\n * @param metadata - 変更前の webm における ファイル先頭から 最初の Cluster 要素までの 要素\n * @param duration - Duration (TimecodeScale)\n * @param cues - cue points for clusters\n * @deprecated @param clusterPtrs - 変更前の webm における SeekHead に追加する Cluster 要素 への start pointer\n * @deprecated @param cueInfos - please use cues.\n */function putRefinedMetaData(metadata,info){if(Array.isArray(info.cueInfos)&&!Array.isArray(info.cues)){console.warn(\"putRefinedMetaData: info.cueInfos property is deprecated. please use info.cues\");info.cues=info.cueInfos;}var ebml=[];var payload=[];for(var i_1=0;i_1<metadata.length;i_1++){var elm=metadata[i_1];if(elm.type===\"m\"&&elm.name===\"Segment\"){ebml=metadata.slice(0,i_1);payload=metadata.slice(i_1);if(elm.unknownSize){payload.shift();// remove segment tag\nbreak;}throw new Error(\"this metadata is not streaming webm file\");}}// *0    *4    *5  *36      *40   *48=segmentOffset              *185=originalPayloadOffsetEnd\n// |     |     |   |        |     |                              |\n// [EBML][size]....[Segment][size][Info][size][Duration][size]...[Cluster]\n// |               |        |^inf |                              |\n// |               +segmentSiz(12)+                              |\n// +-ebmlSize(36)--+        |     +-payloadSize(137)-------------+offsetEndDiff+\n//                 |        |     +-newPayloadSize(??)-------------------------+\n//                 |        |     |                                            |\n//                 [Segment][size][Info][size][Duration][size]....[size][value][Cluster]\n//                           ^                                                 |\n//                           |                                                 *??=newPayloadOffsetEnd\n//                           inf\nif(!(payload[payload.length-1].dataEnd>0)){throw new Error(\"metadata dataEnd has wrong number\");}var originalPayloadOffsetEnd=payload[payload.length-1].dataEnd;// = first cluster ptr\nvar ebmlSize=ebml[ebml.length-1].dataEnd;// = first segment ptr\nvar refinedEBMLSize=new EBMLEncoder_1.default().encode(ebml).byteLength;var offsetDiff=refinedEBMLSize-ebmlSize;var payloadSize=originalPayloadOffsetEnd-payload[0].tagStart;var segmentSize=payload[0].tagStart-ebmlSize;var segmentOffset=payload[0].tagStart;var segmentTagBuf=new exports.Buffer([0x18,0x53,0x80,0x67]);// Segment\nvar segmentSizeBuf=new exports.Buffer('01ffffffffffffff','hex');// Segmentの最後の位置は無数の Cluster 依存なので。 writeVint(newPayloadSize).byteLength ではなく、 infinity.\nvar _segmentSize=segmentTagBuf.byteLength+segmentSizeBuf.byteLength;// == segmentSize\nvar newPayloadSize=payloadSize;// We need the size to be stable between two refinements in order for our offsets to be correct\n// Bound the number of possible refinements so we can't go infinate if something goes wrong\nvar i;for(i=1;i<20;i++){var newPayloadOffsetEnd=ebmlSize+_segmentSize+newPayloadSize;var offsetEndDiff=newPayloadOffsetEnd-originalPayloadOffsetEnd;var sizeDiff=offsetDiff+offsetEndDiff;var refined=refineMetadata(payload,sizeDiff,info);var newNewRefinedSize=new EBMLEncoder_1.default().encode(refined).byteLength;// 一旦 seekhead を作って自身のサイズを調べる\nif(newNewRefinedSize===newPayloadSize){// Size is stable\nreturn new EBMLEncoder_1.default().encode([].concat(ebml,[{type:\"m\",name:\"Segment\",isEnd:false,unknownSize:true}],refined));}newPayloadSize=newNewRefinedSize;}throw new Error(\"unable to refine metadata, stable size could not be found in \"+i+\" iterations!\");}exports.putRefinedMetaData=putRefinedMetaData;// Given a list of EBMLElementBuffers, returns their encoded size in bytes\nfunction encodedSizeOfEbml(refinedMetaData){var encorder=new EBMLEncoder_1.default();return refinedMetaData.reduce(function(lst,elm){return lst.concat(encorder.encode([elm]));},[]).reduce(function(o,buf){return o+buf.byteLength;},0);}function refineMetadata(mesetadata,sizeDiff,info){var duration=info.duration,clusterPtrs=info.clusterPtrs,cues=info.cues;var _metadata=mesetadata.slice(0);if(typeof duration===\"number\"){// duration を追加する\nvar overwrited_1=false;_metadata.forEach(function(elm){if(elm.type===\"f\"&&elm.name===\"Duration\"){overwrited_1=true;elm.data=createFloatBuffer(duration,8);}});if(!overwrited_1){insertTag(_metadata,\"Info\",[{name:\"Duration\",type:\"f\",data:createFloatBuffer(duration,8)}]);}}if(Array.isArray(cues)){insertTag(_metadata,\"Cues\",create_cue(cues,sizeDiff));}var seekhead_children=[];if(Array.isArray(clusterPtrs)){console.warn(\"append cluster pointers to seekhead is deprecated. please use cues\");seekhead_children=create_seek_from_clusters(clusterPtrs,sizeDiff);}// remove seek info\n/*\n    _metadata = _metadata.filter((elm)=> !(\n      elm.name === \"Seek\" ||\n      elm.name === \"SeekID\" ||\n      elm.name === \"SeekPosition\") );\n    */ // working on progress\n//seekhead_children = seekhead_children.concat(create_seekhead(_metadata));\ninsertTag(_metadata,\"SeekHead\",seekhead_children,true);return _metadata;}function create_seekhead(metadata,sizeDiff){var seeks=[];[\"Info\",\"Tracks\",\"Cues\"].forEach(function(tagName){var tagStarts=metadata.filter(function(elm){return elm.type===\"m\"&&elm.name===tagName&&elm.isEnd===false;}).map(function(elm){return elm[\"tagStart\"];});var tagStart=tagStarts[0];if(typeof tagStart!==\"number\"){return;}seeks.push({name:\"Seek\",type:\"m\",isEnd:false});switch(tagName){case\"Info\":seeks.push({name:\"SeekID\",type:\"b\",data:new exports.Buffer([0x15,0x49,0xA9,0x66])});break;case\"Tracks\":seeks.push({name:\"SeekID\",type:\"b\",data:new exports.Buffer([0x16,0x54,0xAE,0x6B])});break;case\"Cues\":seeks.push({name:\"SeekID\",type:\"b\",data:new exports.Buffer([0x1C,0x53,0xBB,0x6B])});break;}seeks.push({name:\"SeekPosition\",type:\"u\",data:createUIntBuffer(tagStart+sizeDiff)});seeks.push({name:\"Seek\",type:\"m\",isEnd:true});});return seeks;}function create_seek_from_clusters(clusterPtrs,sizeDiff){var seeks=[];clusterPtrs.forEach(function(start){seeks.push({name:\"Seek\",type:\"m\",isEnd:false});// [0x1F, 0x43, 0xB6, 0x75] で Cluster 意\nseeks.push({name:\"SeekID\",type:\"b\",data:new exports.Buffer([0x1F,0x43,0xB6,0x75])});seeks.push({name:\"SeekPosition\",type:\"u\",data:createUIntBuffer(start+sizeDiff)});seeks.push({name:\"Seek\",type:\"m\",isEnd:true});});return seeks;}function create_cue(cueInfos,sizeDiff){var cues=[];cueInfos.forEach(function(_a){var CueTrack=_a.CueTrack,CueClusterPosition=_a.CueClusterPosition,CueTime=_a.CueTime;cues.push({name:\"CuePoint\",type:\"m\",isEnd:false});cues.push({name:\"CueTime\",type:\"u\",data:createUIntBuffer(CueTime)});cues.push({name:\"CueTrackPositions\",type:\"m\",isEnd:false});cues.push({name:\"CueTrack\",type:\"u\",data:createUIntBuffer(CueTrack)});// video track\ncues.push({name:\"CueClusterPosition\",type:\"u\",data:createUIntBuffer(CueClusterPosition+sizeDiff)});cues.push({name:\"CueTrackPositions\",type:\"m\",isEnd:true});cues.push({name:\"CuePoint\",type:\"m\",isEnd:true});});return cues;}function insertTag(_metadata,tagName,children,insertHead){if(insertHead===void 0){insertHead=false;}// find the tagname from _metadata\nvar idx=-1;for(var i=0;i<_metadata.length;i++){var elm=_metadata[i];if(elm.type===\"m\"&&elm.name===tagName&&elm.isEnd===false){idx=i;break;}}if(idx>=0){// insert [<CuePoint />] to <Cues />\nArray.prototype.splice.apply(_metadata,[idx+1,0].concat(children));}else if(insertHead){[].concat([{name:tagName,type:\"m\",isEnd:false}],children,[{name:tagName,type:\"m\",isEnd:true}]).reverse().forEach(function(elm){_metadata.unshift(elm);});}else{// metadata 末尾に <Cues /> を追加\n// insert <Cues />\n_metadata.push({name:tagName,type:\"m\",isEnd:false});children.forEach(function(elm){_metadata.push(elm);});_metadata.push({name:tagName,type:\"m\",isEnd:true});}}// alter Buffer.concat - https://github.com/feross/buffer/issues/154\nfunction concat(list){//return Buffer.concat.apply(Buffer, list);\nvar i=0;var length=0;for(;i<list.length;++i){length+=list[i].length;}var buffer=exports.Buffer.allocUnsafe(length);var pos=0;for(i=0;i<list.length;++i){var buf=list[i];buf.copy(buffer,pos);pos+=buf.length;}return buffer;}exports.concat=concat;function encodeValueToBuffer(elm){var data=new exports.Buffer(0);if(elm.type===\"m\"){return elm;}switch(elm.type){case\"u\":data=createUIntBuffer(elm.value);break;case\"i\":data=createIntBuffer(elm.value);break;case\"f\":data=createFloatBuffer(elm.value);break;case\"s\":data=new exports.Buffer(elm.value,'ascii');break;case\"8\":data=new exports.Buffer(elm.value,'utf8');break;case\"b\":data=elm.value;break;case\"d\":data=new int64_buffer_1.Int64BE(elm.value.getTime().toString()).toBuffer();break;}return Object.assign({},elm,{data:data});}exports.encodeValueToBuffer=encodeValueToBuffer;function createUIntBuffer(value){// Big-endian, any size from 1 to 8\n// but js number is float64, so max 6 bit octets\nvar bytes=1;for(;value>=Math.pow(2,8*bytes);bytes++){}if(bytes>=7){console.warn(\"7bit or more bigger uint not supported.\");return new int64_buffer_1.Uint64BE(value).toBuffer();}var data=new exports.Buffer(bytes);data.writeUIntBE(value,0,bytes);return data;}exports.createUIntBuffer=createUIntBuffer;function createIntBuffer(value){// Big-endian, any size from 1 to 8 octets\n// but js number is float64, so max 6 bit\nvar bytes=1;for(;value>=Math.pow(2,8*bytes);bytes++){}if(bytes>=7){console.warn(\"7bit or more bigger uint not supported.\");return new int64_buffer_1.Int64BE(value).toBuffer();}var data=new exports.Buffer(bytes);data.writeIntBE(value,0,bytes);return data;}exports.createIntBuffer=createIntBuffer;function createFloatBuffer(value,bytes){if(bytes===void 0){bytes=8;}// Big-endian, defined for 4 and 8 octets (32, 64 bits)\n// js number is float64 so 8 bytes.\nif(bytes===8){// 64bit\nvar data=new exports.Buffer(8);data.writeDoubleBE(value,0);return data;}else if(bytes===4){// 32bit\nvar data=new exports.Buffer(4);data.writeFloatBE(value,0);return data;}else{throw new Error(\"float type bits must 4bytes or 8bytes\");}}exports.createFloatBuffer=createFloatBuffer;function convertEBMLDateToJSDate(int64str){if(int64str instanceof Date){return int64str;}return new Date(new Date(\"2001-01-01T00:00:00.000Z\").getTime()+Number(int64str)/1000/1000);}exports.convertEBMLDateToJSDate=convertEBMLDateToJSDate;","map":{"version":3,"sources":["/Users/randyadams/IMMORTIFYV2/immortify-app-client/src/react-video-recorder-master/node_modules/ts-ebml/lib/tools.js"],"names":["Object","defineProperty","exports","value","int64_buffer_1","require","EBMLEncoder_1","_Buffer","_tools","_block","Buffer","readVint","writeVint","ebmlBlock","readBlock","buf","encodeTag","tagId","tagData","unknownSize","concat","length","WebPFrameFilter","elms","WebPBlockFilter","reduce","lst","elm","o","data","frames","frame","webpBuf","VP8BitStreamToRiffWebPBuffer","webp","Blob","type","name","hasWebP","some","startcode","slice","toString","VP8Chunk","createRIFFChunk","WebPChunk","FourCC","chunk","chunkSize","writeUInt32LE","byteLength","substr","makeMetadataSeekable","originalMetadata","duration","cuesInfo","header","extractElement","headerSize","encodedSizeOfEbml","segmentContentStartPos","originalMetadataSize","dataEnd","info","removeElement","splice","createFloatBuffer","infoSize","tracks","tracksSize","seekHeadSize","seekHead","cuesSize","cues","lastSizeDifference","maxIterations","_loop_1","i","infoStart","tracksStart","cuesStart","newMetadataSize","sizeDifference","push","isEnd","createUIntBuffer","forEach","_a","CueTrack","CueClusterPosition","CueTime","Error","state_1","finalMetadata","apply","result","default","encode","idName","metadata","start","element","putRefinedMetaData","Array","isArray","cueInfos","console","warn","ebml","payload","i_1","shift","originalPayloadOffsetEnd","ebmlSize","refinedEBMLSize","offsetDiff","payloadSize","tagStart","segmentSize","segmentOffset","segmentTagBuf","segmentSizeBuf","_segmentSize","newPayloadSize","newPayloadOffsetEnd","offsetEndDiff","sizeDiff","refined","refineMetadata","newNewRefinedSize","refinedMetaData","encorder","mesetadata","clusterPtrs","_metadata","overwrited_1","insertTag","create_cue","seekhead_children","create_seek_from_clusters","create_seekhead","seeks","tagName","tagStarts","filter","map","children","insertHead","idx","prototype","reverse","unshift","list","buffer","allocUnsafe","pos","copy","encodeValueToBuffer","createIntBuffer","Int64BE","getTime","toBuffer","assign","bytes","Math","pow","Uint64BE","writeUIntBE","writeIntBE","writeDoubleBE","writeFloatBE","convertEBMLDateToJSDate","int64str","Date","Number"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/// <reference types=\"node\"/>\nvar int64_buffer_1 = require(\"int64-buffer\");\nvar EBMLEncoder_1 = require(\"./EBMLEncoder\");\nvar _Buffer = require(\"buffer/\");\nvar _tools = require(\"ebml/lib/ebml/tools\");\nvar _block = require(\"ebml-block\");\nexports.Buffer = _Buffer.Buffer;\nexports.readVint = _tools.readVint;\nexports.writeVint = _tools.writeVint;\nexports.ebmlBlock = _block;\nfunction readBlock(buf) {\n    return exports.ebmlBlock(new exports.Buffer(buf));\n}\nexports.readBlock = readBlock;\n/**\n  * @param end - if end === false then length is unknown\n  */\nfunction encodeTag(tagId, tagData, unknownSize) {\n    if (unknownSize === void 0) { unknownSize = false; }\n    return concat([\n        tagId,\n        unknownSize ?\n            new exports.Buffer('01ffffffffffffff', 'hex') :\n            exports.writeVint(tagData.length),\n        tagData\n    ]);\n}\nexports.encodeTag = encodeTag;\n/**\n * @return - SimpleBlock to WebP Filter\n */\nfunction WebPFrameFilter(elms) {\n    return WebPBlockFilter(elms).reduce(function (lst, elm) {\n        var o = exports.ebmlBlock(elm.data);\n        return o.frames.reduce(function (lst, frame) {\n            // https://developers.Blob.com/speed/webp/docs/riff_container\n            var webpBuf = VP8BitStreamToRiffWebPBuffer(frame);\n            var webp = new Blob([webpBuf], { type: \"image/webp\" });\n            return lst.concat(webp);\n        }, lst);\n    }, []);\n}\nexports.WebPFrameFilter = WebPFrameFilter;\n/**\n * WebP ファイルにできる SimpleBlock の パスフィルタ\n */\nfunction WebPBlockFilter(elms) {\n    return elms.reduce(function (lst, elm) {\n        if (elm.type !== \"b\") {\n            return lst;\n        }\n        if (elm.name !== \"SimpleBlock\") {\n            return lst;\n        }\n        var o = exports.ebmlBlock(elm.data);\n        var hasWebP = o.frames.some(function (frame) {\n            // https://tools.ietf.org/html/rfc6386#section-19.1\n            var startcode = frame.slice(3, 6).toString(\"hex\");\n            return startcode === \"9d012a\";\n        });\n        if (!hasWebP) {\n            return lst;\n        }\n        return lst.concat(elm);\n    }, []);\n}\nexports.WebPBlockFilter = WebPBlockFilter;\n/**\n * @param frame - VP8 BitStream のうち startcode をもつ frame\n * @return - WebP ファイルの ArrayBuffer\n */\nfunction VP8BitStreamToRiffWebPBuffer(frame) {\n    var VP8Chunk = createRIFFChunk(\"VP8 \", frame);\n    var WebPChunk = concat([\n        new exports.Buffer(\"WEBP\", \"ascii\"),\n        VP8Chunk\n    ]);\n    return createRIFFChunk(\"RIFF\", WebPChunk);\n}\nexports.VP8BitStreamToRiffWebPBuffer = VP8BitStreamToRiffWebPBuffer;\n/**\n * RIFF データチャンクを作る\n */\nfunction createRIFFChunk(FourCC, chunk) {\n    var chunkSize = new exports.Buffer(4);\n    chunkSize.writeUInt32LE(chunk.byteLength, 0);\n    return concat([\n        new exports.Buffer(FourCC.substr(0, 4), \"ascii\"),\n        chunkSize,\n        chunk,\n        new exports.Buffer(chunk.byteLength % 2 === 0 ? 0 : 1) // padding\n    ]);\n}\nexports.createRIFFChunk = createRIFFChunk;\n/* Original Metadata\n\n m  0\tEBML\n u  1\t  EBMLVersion 1\n u  1\t  EBMLReadVersion 1\n u  1\t  EBMLMaxIDLength 4\n u  1\t  EBMLMaxSizeLength 8\n s  1\t  DocType webm\n u  1\t  DocTypeVersion 4\n u  1\t  DocTypeReadVersion 2\n m  0\tSegment\n m  1\t  Info                                segmentContentStartPos, all CueClusterPositions provided in info.cues will be relative to here and will need adjusted\n u  2\t    TimecodeScale 1000000\n 8  2\t    MuxingApp Chrome\n 8  2\t    WritingApp Chrome\n m  1\t  Tracks                              tracksStartPos\n m  2\t    TrackEntry\n u  3\t      TrackNumber 1\n u  3\t      TrackUID 31790271978391090\n u  3\t      TrackType 2\n s  3\t      CodecID A_OPUS\n b  3\t      CodecPrivate <Buffer 19>\n m  3\t      Audio\n f  4\t        SamplingFrequency 48000\n u  4\t        Channels 1\n m  2\t    TrackEntry\n u  3\t      TrackNumber 2\n u  3\t      TrackUID 24051277436254136\n u  3\t      TrackType 1\n s  3\t      CodecID V_VP8\n m  3\t      Video\n u  4\t        PixelWidth 1024\n u  4\t        PixelHeight 576\n m  1\t  Cluster                             clusterStartPos\n u  2\t    Timecode 0\n b  2\t    SimpleBlock track:2 timecode:0\tkeyframe:true\tinvisible:false\tdiscardable:false\tlacing:1\n*/\n/* Desired Metadata\n\n m\t0 EBML\n u\t1   EBMLVersion 1\n u\t1   EBMLReadVersion 1\n u\t1   EBMLMaxIDLength 4\n u\t1   EBMLMaxSizeLength 8\n s\t1   DocType webm\n u\t1   DocTypeVersion 4\n u\t1   DocTypeReadVersion 2\n m\t0 Segment\n m\t1   SeekHead                            -> This is SeekPosition 0, so all SeekPositions can be calculated as (bytePos - segmentContentStartPos), which is 44 in this case\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x15, 0x49, 0xA9, 0x66])  Info\n u\t3       SeekPosition                    -> infoStartPos =\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x16, 0x54, 0xAE, 0x6B])  Tracks\n u\t3       SeekPosition { tracksStartPos }\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x1C, 0x53, 0xBB, 0x6B])  Cues\n u\t3       SeekPosition { cuesStartPos }\n m\t1   Info\n f\t2     Duration 32480                    -> overwrite, or insert if it doesn't exist\n u\t2     TimecodeScale 1000000\n 8\t2     MuxingApp Chrome\n 8\t2     WritingApp Chrome\n m\t1   Tracks\n m\t2     TrackEntry\n u\t3       TrackNumber 1\n u\t3       TrackUID 31790271978391090\n u\t3       TrackType 2\n s\t3       CodecID A_OPUS\n b\t3       CodecPrivate <Buffer 19>\n m\t3       Audio\n f\t4         SamplingFrequency 48000\n u\t4         Channels 1\n m\t2     TrackEntry\n u\t3       TrackNumber 2\n u\t3       TrackUID 24051277436254136\n u\t3       TrackType 1\n s\t3       CodecID V_VP8\n m\t3       Video\n u\t4         PixelWidth 1024\n u\t4         PixelHeight 576\n m  1   Cues                                -> cuesStartPos\n m  2     CuePoint\n u  3       CueTime 0\n m  3       CueTrackPositions\n u  4         CueTrack 1\n u  4         CueClusterPosition 3911\n m  2     CuePoint\n u  3       CueTime 600\n m  3       CueTrackPositions\n u  4         CueTrack 1\n u  4         CueClusterPosition 3911\n m  1   Cluster\n u  2     Timecode 0\n b  2     SimpleBlock track:2 timecode:0\tkeyframe:true\tinvisible:false\tdiscardable:false\tlacing:1\n*/\n/**\n * convert the metadata from a streaming webm bytestream to a seekable file by inserting Duration, Seekhead and Cues\n * @param originalMetadata - orginal metadata (everything before the clusters start) from media recorder\n * @param duration - Duration (TimecodeScale)\n * @param cues - cue points for clusters\n */\nfunction makeMetadataSeekable(originalMetadata, duration, cuesInfo) {\n    // extract the header, we can reuse this as-is\n    var header = extractElement(\"EBML\", originalMetadata);\n    var headerSize = encodedSizeOfEbml(header);\n    //console.error(\"Header size: \" + headerSize);\n    //printElementIds(header);\n    // After the header comes the Segment open tag, which in this implementation is always 12 bytes (4 byte id, 8 byte 'unknown length')\n    // After that the segment content starts. All SeekPositions and CueClusterPosition must be relative to segmentContentStartPos\n    var segmentContentStartPos = headerSize + 12;\n    //console.error(\"segmentContentStartPos: \" + segmentContentStartPos);    \n    // find the original metadata size, and adjust it for header size and Segment start element so we can keep all positions relative to segmentContentStartPos\n    var originalMetadataSize = originalMetadata[originalMetadata.length - 1].dataEnd - segmentContentStartPos;\n    //console.error(\"Original Metadata size: \" + originalMetadataSize);\n    //printElementIds(originalMetadata);\n    // extract the segment info, remove the potentially existing Duration element, and add our own one.\n    var info = extractElement(\"Info\", originalMetadata);\n    removeElement(\"Duration\", info);\n    info.splice(1, 0, { name: \"Duration\", type: \"f\", data: createFloatBuffer(duration, 8) });\n    var infoSize = encodedSizeOfEbml(info);\n    //console.error(\"Info size: \" + infoSize);\n    //printElementIds(info);  \n    // extract the track info, we can re-use this as is\n    var tracks = extractElement(\"Tracks\", originalMetadata);\n    var tracksSize = encodedSizeOfEbml(tracks);\n    //console.error(\"Tracks size: \" + tracksSize);\n    //printElementIds(tracks);  \n    var seekHeadSize = 47; // Initial best guess, but could be slightly larger if the Cues element is huge.\n    var seekHead = [];\n    var cuesSize = 5 + cuesInfo.length * 15; // very rough initial approximation, depends a lot on file size and number of CuePoints                   \n    var cues = [];\n    var lastSizeDifference = -1; // \n    // The size of SeekHead and Cues elements depends on how many bytes the offsets values can be encoded in.\n    // The actual offsets in CueClusterPosition depend on the final size of the SeekHead and Cues elements\n    // We need to iteratively converge to a stable solution.\n    var maxIterations = 10;\n    var _loop_1 = function (i) {\n        // SeekHead starts at 0\n        var infoStart = seekHeadSize; // Info comes directly after SeekHead\n        var tracksStart = infoStart + infoSize; // Tracks comes directly after Info\n        var cuesStart = tracksStart + tracksSize; // Cues starts directly after \n        var newMetadataSize = cuesStart + cuesSize; // total size of metadata  \n        // This is the offset all CueClusterPositions should be adjusted by due to the metadata size changing.\n        var sizeDifference = newMetadataSize - originalMetadataSize;\n        // console.error(`infoStart: ${infoStart}, infoSize: ${infoSize}`);\n        // console.error(`tracksStart: ${tracksStart}, tracksSize: ${tracksSize}`);\n        // console.error(`cuesStart: ${cuesStart}, cuesSize: ${cuesSize}`);\n        // console.error(`originalMetadataSize: ${originalMetadataSize}, newMetadataSize: ${newMetadataSize}, sizeDifference: ${sizeDifference}`); \n        // create the SeekHead element\n        seekHead = [];\n        seekHead.push({ name: \"SeekHead\", type: \"m\", isEnd: false });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        seekHead.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x15, 0x49, 0xA9, 0x66]) }); // Info\n        seekHead.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(infoStart) });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: true });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        seekHead.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x16, 0x54, 0xAE, 0x6B]) }); // Tracks\n        seekHead.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(tracksStart) });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: true });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        seekHead.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x1C, 0x53, 0xBB, 0x6B]) }); // Cues\n        seekHead.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(cuesStart) });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: true });\n        seekHead.push({ name: \"SeekHead\", type: \"m\", isEnd: true });\n        seekHeadSize = encodedSizeOfEbml(seekHead);\n        //console.error(\"SeekHead size: \" + seekHeadSize);\n        //printElementIds(seekHead);  \n        // create the Cues element\n        cues = [];\n        cues.push({ name: \"Cues\", type: \"m\", isEnd: false });\n        cuesInfo.forEach(function (_a) {\n            var CueTrack = _a.CueTrack, CueClusterPosition = _a.CueClusterPosition, CueTime = _a.CueTime;\n            cues.push({ name: \"CuePoint\", type: \"m\", isEnd: false });\n            cues.push({ name: \"CueTime\", type: \"u\", data: createUIntBuffer(CueTime) });\n            cues.push({ name: \"CueTrackPositions\", type: \"m\", isEnd: false });\n            cues.push({ name: \"CueTrack\", type: \"u\", data: createUIntBuffer(CueTrack) });\n            //console.error(`CueClusterPosition: ${CueClusterPosition}, Corrected to: ${CueClusterPosition - segmentContentStartPos}  , offset by ${sizeDifference} to become ${(CueClusterPosition - segmentContentStartPos) + sizeDifference - segmentContentStartPos}`);\n            // EBMLReader returns CueClusterPosition with absolute byte offsets. The Cues section expects them as offsets from the first level 1 element of the Segment, so we need to adjust it.\n            CueClusterPosition -= segmentContentStartPos;\n            // We also need to adjust to take into account the change in metadata size from when EBMLReader read the original metadata.\n            CueClusterPosition += sizeDifference;\n            cues.push({ name: \"CueClusterPosition\", type: \"u\", data: createUIntBuffer(CueClusterPosition) });\n            cues.push({ name: \"CueTrackPositions\", type: \"m\", isEnd: true });\n            cues.push({ name: \"CuePoint\", type: \"m\", isEnd: true });\n        });\n        cues.push({ name: \"Cues\", type: \"m\", isEnd: true });\n        cuesSize = encodedSizeOfEbml(cues);\n        //console.error(\"Cues size: \" + cuesSize);   \n        //console.error(\"Cue count: \" + cuesInfo.length);\n        //printElementIds(cues);      \n        // If the new MetadataSize is not the same as the previous iteration, we need to run once more.\n        if (lastSizeDifference !== sizeDifference) {\n            lastSizeDifference = sizeDifference;\n            if (i === maxIterations - 1) {\n                throw new Error(\"Failed to converge to a stable metadata size\");\n            }\n        }\n        else {\n            return \"break\";\n        }\n    };\n    for (var i = 0; i < maxIterations; i++) {\n        var state_1 = _loop_1(i);\n        if (state_1 === \"break\")\n            break;\n    }\n    var finalMetadata = [].concat.apply([], [\n        header,\n        { name: \"Segment\", type: \"m\", isEnd: false, unknownSize: true },\n        seekHead,\n        info,\n        tracks,\n        cues\n    ]);\n    var result = new EBMLEncoder_1.default().encode(finalMetadata);\n    //printElementIds(finalMetadata);\n    //console.error(`Final metadata buffer size: ${result.byteLength}`);\n    //console.error(`Final metadata buffer size without header and segment: ${result.byteLength-segmentContentStartPos}`);\n    return result;\n}\nexports.makeMetadataSeekable = makeMetadataSeekable;\n/**\n * print all element id names in a list\n\n * @param metadata - array of EBML elements to print\n *\nexport function printElementIds(metadata: EBML.EBMLElementBuffer[]) {\n\n  let result: EBML.EBMLElementBuffer[] = [];\n  let start: number = -1;\n\n  for (let i = 0; i < metadata.length; i++) {\n    console.error(\"\\t id: \" + metadata[i].name);\n  }\n}\n*/\n/**\n * remove all occurances of an EBML element from an array of elements\n * If it's a MasterElement you will also remove the content. (everything between start and end)\n * @param idName - name of the EBML Element to remove.\n * @param metadata - array of EBML elements to search\n */\nfunction removeElement(idName, metadata) {\n    var result = [];\n    var start = -1;\n    for (var i = 0; i < metadata.length; i++) {\n        var element = metadata[i];\n        if (element.name === idName) {\n            // if it's a Master element, extract the start and end element, and everything in between\n            if (element.type === \"m\") {\n                if (!element.isEnd) {\n                    start = i;\n                }\n                else {\n                    // we've reached the end, extract the whole thing\n                    if (start == -1)\n                        throw new Error(\"Detected \" + idName + \" closing element before finding the start\");\n                    metadata.splice(start, i - start + 1);\n                    return;\n                }\n            }\n            else {\n                // not a Master element, so we've found what we're looking for.\n                metadata.splice(i, 1);\n                return;\n            }\n        }\n    }\n}\nexports.removeElement = removeElement;\n/**\n * extract the first occurance of an EBML tag from a flattened array of EBML data.\n * If it's a MasterElement you will also get the content. (everything between start and end)\n * @param idName - name of the EBML Element to extract.\n * @param metadata - array of EBML elements to search\n */\nfunction extractElement(idName, metadata) {\n    var result = [];\n    var start = -1;\n    for (var i = 0; i < metadata.length; i++) {\n        var element = metadata[i];\n        if (element.name === idName) {\n            // if it's a Master element, extract the start and end element, and everything in between\n            if (element.type === \"m\") {\n                if (!element.isEnd) {\n                    start = i;\n                }\n                else {\n                    // we've reached the end, extract the whole thing\n                    if (start == -1)\n                        throw new Error(\"Detected \" + idName + \" closing element before finding the start\");\n                    result = metadata.slice(start, i + 1);\n                    break;\n                }\n            }\n            else {\n                // not a Master element, so we've found what we're looking for.\n                result.push(metadata[i]);\n                break;\n            }\n        }\n    }\n    return result;\n}\nexports.extractElement = extractElement;\n/**\n * @deprecated\n * metadata に対して duration と seekhead を追加した metadata を返す\n * @param metadata - 変更前の webm における ファイル先頭から 最初の Cluster 要素までの 要素\n * @param duration - Duration (TimecodeScale)\n * @param cues - cue points for clusters\n * @deprecated @param clusterPtrs - 変更前の webm における SeekHead に追加する Cluster 要素 への start pointer\n * @deprecated @param cueInfos - please use cues.\n */\nfunction putRefinedMetaData(metadata, info) {\n    if (Array.isArray(info.cueInfos) && !Array.isArray(info.cues)) {\n        console.warn(\"putRefinedMetaData: info.cueInfos property is deprecated. please use info.cues\");\n        info.cues = info.cueInfos;\n    }\n    var ebml = [];\n    var payload = [];\n    for (var i_1 = 0; i_1 < metadata.length; i_1++) {\n        var elm = metadata[i_1];\n        if (elm.type === \"m\" && elm.name === \"Segment\") {\n            ebml = metadata.slice(0, i_1);\n            payload = metadata.slice(i_1);\n            if (elm.unknownSize) {\n                payload.shift(); // remove segment tag\n                break;\n            }\n            throw new Error(\"this metadata is not streaming webm file\");\n        }\n    }\n    // *0    *4    *5  *36      *40   *48=segmentOffset              *185=originalPayloadOffsetEnd\n    // |     |     |   |        |     |                              |\n    // [EBML][size]....[Segment][size][Info][size][Duration][size]...[Cluster]\n    // |               |        |^inf |                              |\n    // |               +segmentSiz(12)+                              |\n    // +-ebmlSize(36)--+        |     +-payloadSize(137)-------------+offsetEndDiff+\n    //                 |        |     +-newPayloadSize(??)-------------------------+\n    //                 |        |     |                                            |\n    //                 [Segment][size][Info][size][Duration][size]....[size][value][Cluster]\n    //                           ^                                                 |\n    //                           |                                                 *??=newPayloadOffsetEnd\n    //                           inf\n    if (!(payload[payload.length - 1].dataEnd > 0)) {\n        throw new Error(\"metadata dataEnd has wrong number\");\n    }\n    var originalPayloadOffsetEnd = payload[payload.length - 1].dataEnd; // = first cluster ptr\n    var ebmlSize = ebml[ebml.length - 1].dataEnd; // = first segment ptr\n    var refinedEBMLSize = new EBMLEncoder_1.default().encode(ebml).byteLength;\n    var offsetDiff = refinedEBMLSize - ebmlSize;\n    var payloadSize = originalPayloadOffsetEnd - payload[0].tagStart;\n    var segmentSize = payload[0].tagStart - ebmlSize;\n    var segmentOffset = payload[0].tagStart;\n    var segmentTagBuf = new exports.Buffer([0x18, 0x53, 0x80, 0x67]); // Segment\n    var segmentSizeBuf = new exports.Buffer('01ffffffffffffff', 'hex'); // Segmentの最後の位置は無数の Cluster 依存なので。 writeVint(newPayloadSize).byteLength ではなく、 infinity.\n    var _segmentSize = segmentTagBuf.byteLength + segmentSizeBuf.byteLength; // == segmentSize\n    var newPayloadSize = payloadSize;\n    // We need the size to be stable between two refinements in order for our offsets to be correct\n    // Bound the number of possible refinements so we can't go infinate if something goes wrong\n    var i;\n    for (i = 1; i < 20; i++) {\n        var newPayloadOffsetEnd = ebmlSize + _segmentSize + newPayloadSize;\n        var offsetEndDiff = newPayloadOffsetEnd - originalPayloadOffsetEnd;\n        var sizeDiff = offsetDiff + offsetEndDiff;\n        var refined = refineMetadata(payload, sizeDiff, info);\n        var newNewRefinedSize = new EBMLEncoder_1.default().encode(refined).byteLength; // 一旦 seekhead を作って自身のサイズを調べる\n        if (newNewRefinedSize === newPayloadSize) {\n            // Size is stable\n            return new EBMLEncoder_1.default().encode([].concat(ebml, [{ type: \"m\", name: \"Segment\", isEnd: false, unknownSize: true }], refined));\n        }\n        newPayloadSize = newNewRefinedSize;\n    }\n    throw new Error(\"unable to refine metadata, stable size could not be found in \" + i + \" iterations!\");\n}\nexports.putRefinedMetaData = putRefinedMetaData;\n// Given a list of EBMLElementBuffers, returns their encoded size in bytes\nfunction encodedSizeOfEbml(refinedMetaData) {\n    var encorder = new EBMLEncoder_1.default();\n    return refinedMetaData.reduce(function (lst, elm) { return lst.concat(encorder.encode([elm])); }, []).reduce(function (o, buf) { return o + buf.byteLength; }, 0);\n}\nfunction refineMetadata(mesetadata, sizeDiff, info) {\n    var duration = info.duration, clusterPtrs = info.clusterPtrs, cues = info.cues;\n    var _metadata = mesetadata.slice(0);\n    if (typeof duration === \"number\") {\n        // duration を追加する\n        var overwrited_1 = false;\n        _metadata.forEach(function (elm) {\n            if (elm.type === \"f\" && elm.name === \"Duration\") {\n                overwrited_1 = true;\n                elm.data = createFloatBuffer(duration, 8);\n            }\n        });\n        if (!overwrited_1) {\n            insertTag(_metadata, \"Info\", [{ name: \"Duration\", type: \"f\", data: createFloatBuffer(duration, 8) }]);\n        }\n    }\n    if (Array.isArray(cues)) {\n        insertTag(_metadata, \"Cues\", create_cue(cues, sizeDiff));\n    }\n    var seekhead_children = [];\n    if (Array.isArray(clusterPtrs)) {\n        console.warn(\"append cluster pointers to seekhead is deprecated. please use cues\");\n        seekhead_children = create_seek_from_clusters(clusterPtrs, sizeDiff);\n    }\n    // remove seek info\n    /*\n    _metadata = _metadata.filter((elm)=> !(\n      elm.name === \"Seek\" ||\n      elm.name === \"SeekID\" ||\n      elm.name === \"SeekPosition\") );\n    */\n    // working on progress\n    //seekhead_children = seekhead_children.concat(create_seekhead(_metadata));\n    insertTag(_metadata, \"SeekHead\", seekhead_children, true);\n    return _metadata;\n}\nfunction create_seekhead(metadata, sizeDiff) {\n    var seeks = [];\n    [\"Info\", \"Tracks\", \"Cues\"].forEach(function (tagName) {\n        var tagStarts = metadata.filter(function (elm) { return elm.type === \"m\" && elm.name === tagName && elm.isEnd === false; }).map(function (elm) { return elm[\"tagStart\"]; });\n        var tagStart = tagStarts[0];\n        if (typeof tagStart !== \"number\") {\n            return;\n        }\n        seeks.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        switch (tagName) {\n            case \"Info\":\n                seeks.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x15, 0x49, 0xA9, 0x66]) });\n                break;\n            case \"Tracks\":\n                seeks.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x16, 0x54, 0xAE, 0x6B]) });\n                break;\n            case \"Cues\":\n                seeks.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x1C, 0x53, 0xBB, 0x6B]) });\n                break;\n        }\n        seeks.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(tagStart + sizeDiff) });\n        seeks.push({ name: \"Seek\", type: \"m\", isEnd: true });\n    });\n    return seeks;\n}\nfunction create_seek_from_clusters(clusterPtrs, sizeDiff) {\n    var seeks = [];\n    clusterPtrs.forEach(function (start) {\n        seeks.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        // [0x1F, 0x43, 0xB6, 0x75] で Cluster 意\n        seeks.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x1F, 0x43, 0xB6, 0x75]) });\n        seeks.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(start + sizeDiff) });\n        seeks.push({ name: \"Seek\", type: \"m\", isEnd: true });\n    });\n    return seeks;\n}\nfunction create_cue(cueInfos, sizeDiff) {\n    var cues = [];\n    cueInfos.forEach(function (_a) {\n        var CueTrack = _a.CueTrack, CueClusterPosition = _a.CueClusterPosition, CueTime = _a.CueTime;\n        cues.push({ name: \"CuePoint\", type: \"m\", isEnd: false });\n        cues.push({ name: \"CueTime\", type: \"u\", data: createUIntBuffer(CueTime) });\n        cues.push({ name: \"CueTrackPositions\", type: \"m\", isEnd: false });\n        cues.push({ name: \"CueTrack\", type: \"u\", data: createUIntBuffer(CueTrack) }); // video track\n        cues.push({ name: \"CueClusterPosition\", type: \"u\", data: createUIntBuffer(CueClusterPosition + sizeDiff) });\n        cues.push({ name: \"CueTrackPositions\", type: \"m\", isEnd: true });\n        cues.push({ name: \"CuePoint\", type: \"m\", isEnd: true });\n    });\n    return cues;\n}\nfunction insertTag(_metadata, tagName, children, insertHead) {\n    if (insertHead === void 0) { insertHead = false; }\n    // find the tagname from _metadata\n    var idx = -1;\n    for (var i = 0; i < _metadata.length; i++) {\n        var elm = _metadata[i];\n        if (elm.type === \"m\" && elm.name === tagName && elm.isEnd === false) {\n            idx = i;\n            break;\n        }\n    }\n    if (idx >= 0) {\n        // insert [<CuePoint />] to <Cues />\n        Array.prototype.splice.apply(_metadata, [idx + 1, 0].concat(children));\n    }\n    else if (insertHead) {\n        [].concat([{ name: tagName, type: \"m\", isEnd: false }], children, [{ name: tagName, type: \"m\", isEnd: true }]).reverse().forEach(function (elm) { _metadata.unshift(elm); });\n    }\n    else {\n        // metadata 末尾に <Cues /> を追加\n        // insert <Cues />\n        _metadata.push({ name: tagName, type: \"m\", isEnd: false });\n        children.forEach(function (elm) { _metadata.push(elm); });\n        _metadata.push({ name: tagName, type: \"m\", isEnd: true });\n    }\n}\n// alter Buffer.concat - https://github.com/feross/buffer/issues/154\nfunction concat(list) {\n    //return Buffer.concat.apply(Buffer, list);\n    var i = 0;\n    var length = 0;\n    for (; i < list.length; ++i) {\n        length += list[i].length;\n    }\n    var buffer = exports.Buffer.allocUnsafe(length);\n    var pos = 0;\n    for (i = 0; i < list.length; ++i) {\n        var buf = list[i];\n        buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n}\nexports.concat = concat;\nfunction encodeValueToBuffer(elm) {\n    var data = new exports.Buffer(0);\n    if (elm.type === \"m\") {\n        return elm;\n    }\n    switch (elm.type) {\n        case \"u\":\n            data = createUIntBuffer(elm.value);\n            break;\n        case \"i\":\n            data = createIntBuffer(elm.value);\n            break;\n        case \"f\":\n            data = createFloatBuffer(elm.value);\n            break;\n        case \"s\":\n            data = new exports.Buffer(elm.value, 'ascii');\n            break;\n        case \"8\":\n            data = new exports.Buffer(elm.value, 'utf8');\n            break;\n        case \"b\":\n            data = elm.value;\n            break;\n        case \"d\":\n            data = new int64_buffer_1.Int64BE(elm.value.getTime().toString()).toBuffer();\n            break;\n    }\n    return Object.assign({}, elm, { data: data });\n}\nexports.encodeValueToBuffer = encodeValueToBuffer;\nfunction createUIntBuffer(value) {\n    // Big-endian, any size from 1 to 8\n    // but js number is float64, so max 6 bit octets\n    var bytes = 1;\n    for (; value >= Math.pow(2, 8 * bytes); bytes++) { }\n    if (bytes >= 7) {\n        console.warn(\"7bit or more bigger uint not supported.\");\n        return new int64_buffer_1.Uint64BE(value).toBuffer();\n    }\n    var data = new exports.Buffer(bytes);\n    data.writeUIntBE(value, 0, bytes);\n    return data;\n}\nexports.createUIntBuffer = createUIntBuffer;\nfunction createIntBuffer(value) {\n    // Big-endian, any size from 1 to 8 octets\n    // but js number is float64, so max 6 bit\n    var bytes = 1;\n    for (; value >= Math.pow(2, 8 * bytes); bytes++) { }\n    if (bytes >= 7) {\n        console.warn(\"7bit or more bigger uint not supported.\");\n        return new int64_buffer_1.Int64BE(value).toBuffer();\n    }\n    var data = new exports.Buffer(bytes);\n    data.writeIntBE(value, 0, bytes);\n    return data;\n}\nexports.createIntBuffer = createIntBuffer;\nfunction createFloatBuffer(value, bytes) {\n    if (bytes === void 0) { bytes = 8; }\n    // Big-endian, defined for 4 and 8 octets (32, 64 bits)\n    // js number is float64 so 8 bytes.\n    if (bytes === 8) {\n        // 64bit\n        var data = new exports.Buffer(8);\n        data.writeDoubleBE(value, 0);\n        return data;\n    }\n    else if (bytes === 4) {\n        // 32bit\n        var data = new exports.Buffer(4);\n        data.writeFloatBE(value, 0);\n        return data;\n    }\n    else {\n        throw new Error(\"float type bits must 4bytes or 8bytes\");\n    }\n}\nexports.createFloatBuffer = createFloatBuffer;\nfunction convertEBMLDateToJSDate(int64str) {\n    if (int64str instanceof Date) {\n        return int64str;\n    }\n    return new Date(new Date(\"2001-01-01T00:00:00.000Z\").getTime() + (Number(int64str) / 1000 / 1000));\n}\nexports.convertEBMLDateToJSDate = convertEBMLDateToJSDate;\n"]},"metadata":{},"sourceType":"module"}